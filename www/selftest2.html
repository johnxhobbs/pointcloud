<!DOCTYPE html>
<!--
  selftest2.html - Minimal WebGL2 point cloud renderer demo
  - Renders 10,000 white points (gl.POINTS, size 5) centered at origin
  - Mouse drag to orbit (trackball), wheel to zoom
  - Perspective camera, no external libs except gl-matrix (CDN, for mat4)
  - Resizes with window
  - Logs FPS and visible point count (10,000) to console each frame
  - All code is standalone in this file
-->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>WebGL2 Point Cloud Selftest2</title>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; background: #222; }
    body { width: 100vw; height: 100vh; overflow: hidden; }
    #glcanvas { width: 100vw; height: 100vh; display: block; background: #111; }
    #instructions {
      position: absolute; top: 12px; left: 12px; background: rgba(0,0,0,0.6); color: #fff;
      padding: 10px 16px; border-radius: 7px; font-family: monospace; z-index: 10; font-size: 15px;
    }
  </style>
  <!-- Minimal gl-matrix just for mat4 (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/gl-matrix@3.4.3/gl-matrix-min.js"></script>
</head>
<body>
  <div id="instructions">
    <b>WebGL2 Point Cloud Demo (1,000,000 pts)</b><br>
    <ul style="margin:8px 0 0 14px; padding:0; font-size:14px;">
      <li>Mouse drag: Orbit</li>
      <li>Mouse wheel: Zoom</li>
    </ul>
    <span style="font-size:13px; color:#aaa;">(Check console for FPS and point count)</span>
  </div>
  <canvas id="glcanvas"></canvas>
  <script>
    // --- Constants ---
    const POINT_COUNT = 1000000;
    const POINT_SIZE = 1.0; // px

    // --- WebGL2 setup ---
    const canvas = document.getElementById('glcanvas');
    const gl = canvas.getContext('webgl2');
    if (!gl) { alert('WebGL2 required'); throw "WebGL2 not supported"; }

    // --- Shaders ---
    const vsSource = `#version 300 es
      in vec3 a_position;
      uniform mat4 u_mvp;
      void main() {
        gl_Position = u_mvp * vec4(a_position, 1.0);
        gl_PointSize = ${POINT_SIZE.toFixed(1)};
      }
    `;
    const fsSource = `#version 300 es
      precision mediump float;
      out vec4 fragColor;
      void main() {
        // Circular point appearance (optional, can comment out for square)
        vec2 pc = gl_PointCoord - vec2(0.5);
        if (dot(pc, pc) > 0.25) discard;
        fragColor = vec4(1.0);
      }
    `;

    function compileShader(src, type) {
      const sh = gl.createShader(type);
      gl.shaderSource(sh, src);
      gl.compileShader(sh);
      if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS))
        throw gl.getShaderInfoLog(sh);
      return sh;
    }

    const prog = gl.createProgram();
    gl.attachShader(prog, compileShader(vsSource, gl.VERTEX_SHADER));
    gl.attachShader(prog, compileShader(fsSource, gl.FRAGMENT_SHADER));
    gl.linkProgram(prog);
    if (!gl.getProgramParameter(prog, gl.LINK_STATUS))
      throw gl.getProgramInfoLog(prog);

    // --- Generate 10,000 random points in a cube centered at origin ---
    const points = new Float32Array(POINT_COUNT * 3);
    for (let i = 0; i < POINT_COUNT; ++i) {
      // Uniform random in [-1,1]^3
      points[3*i  ] = (Math.random() - 0.5) * 2.0;
      points[3*i+1] = (Math.random() - 0.5) * 2.0;
      points[3*i+2] = (Math.random() - 0.5) * 2.0;
    }

    // --- Upload point data to GPU ---
    const vbo = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);

    // --- Get attrib/uniform locations ---
    const loc_a_position = gl.getAttribLocation(prog, "a_position");
    const loc_u_mvp = gl.getUniformLocation(prog, "u_mvp");

    // --- Camera state ---
    let camera = {
      distance: 4.0,                // zoom: distance from origin
      rotX: 0.8,                    // up-down rotation (trackball, radians)
      rotY: 0.9,                    // left-right rotation (trackball, radians)
      target: [0,0,0]
    };

    // --- Handle resizing ---
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    }
    window.addEventListener('resize', resize);
    resize();

    // --- Mouse controls (trackball orbit + zoom) ---
    let isDragging = false, lastX = 0, lastY = 0;
    canvas.addEventListener('mousedown', e => {
      isDragging = true; lastX = e.clientX; lastY = e.clientY;
      canvas.style.cursor = 'grabbing';
    });
    window.addEventListener('mousemove', e => {
      if (!isDragging) return;
      const dx = e.clientX - lastX, dy = e.clientY - lastY;
      lastX = e.clientX; lastY = e.clientY;
      camera.rotY += dx * 0.01;
      camera.rotX += dy * 0.01;
      // Clamp vertical rotation to avoid flipping
      camera.rotX = Math.max(-Math.PI/2+0.01, Math.min(Math.PI/2-0.01, camera.rotX));
    });
    window.addEventListener('mouseup', e => {
      isDragging = false; canvas.style.cursor = 'grab';
    });
    canvas.addEventListener('wheel', e => {
      e.preventDefault();
      camera.distance *= (e.deltaY > 0) ? 1.08 : 0.92;
      camera.distance = Math.max(1.0, Math.min(10.0, camera.distance));
    }, { passive: false });

    // --- Matrices (gl-matrix mat4) ---
    const mat4 = window.glMatrix.mat4;
    let matProj = mat4.create(), matView = mat4.create(), matMVP = mat4.create();

    // --- Animation/render loop ---
    let lastTime = performance.now(), frames = 0, lastFpsTime = performance.now(), fps = 0;
    function render() {
      // --- Camera setup ---
      const aspect = canvas.width / canvas.height;
      mat4.perspective(matProj, Math.PI/4, aspect, 0.01, 100.0);

      // camera "eye" position using spherical coordinates (trackball)
      const r = camera.distance;
      const cx = r * Math.cos(camera.rotX) * Math.sin(camera.rotY);
      const cy = r * Math.sin(camera.rotX);
      const cz = r * Math.cos(camera.rotX) * Math.cos(camera.rotY);
      const eye = [cx, cy, cz];

      mat4.lookAt(matView, eye, camera.target, [0,1,0]);
      mat4.multiply(matMVP, matProj, matView);

      // --- GL state ---
      gl.clearColor(0.1,0.1,0.13,1);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      gl.useProgram(prog);

      // Set uniforms
      gl.uniformMatrix4fv(loc_u_mvp, false, matMVP);

      // Setup attribs
      gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
      gl.enableVertexAttribArray(loc_a_position);
      gl.vertexAttribPointer(loc_a_position, 3, gl.FLOAT, false, 0, 0);

      // Draw points
      gl.enable(gl.DEPTH_TEST);
      gl.drawArrays(gl.POINTS, 0, POINT_COUNT);

      // --- FPS and point count logging ---
      frames++;
      const now = performance.now();
      if (now - lastFpsTime > 1000) {
        fps = (frames * 1000 / (now - lastFpsTime))|0;
        frames = 0; lastFpsTime = now;
        console.log(`[selftest2] FPS: ${fps}  Points drawn: ${POINT_COUNT}`);
      }

      requestAnimationFrame(render);
    }

    // --- Start render loop ---
    render();

    // --- Initial cursor ---
    canvas.style.cursor = 'grab';
  </script>
</body>
</html>
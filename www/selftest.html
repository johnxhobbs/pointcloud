<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Depth-Reflection 3D Renderer</title>
    <style>
        body { margin: 0; padding: 0; background: #000; overflow: hidden; }
        canvas { display: block; }
        #controls { position: absolute; top: 10px; left: 10px; color: white; font-family: monospace; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="controls">
        <div>Points: <span id="pointCount">0</span></div>
        <div>FPS: <span id="fps">0</span></div>
    </div>

    <script>
        // Sample data arrays - replace with your actual data
        // Each index represents a measurement point
        const depth = new Uint16Array(100);     // Smaller dataset for debugging
        const reflect = new Uint16Array(100);   // reflection intensity

        // Fill with simple, predictable test data
        for (let i = 0; i < depth.length; i++) {
            depth[i] = 500 + i * 10;               // 500-1490mm radius (predictable pattern)
            reflect[i] = i * 655;                  // 0-64845 intensity (gradient)
        }

        // Add some "hello world" reference points with known positions
        const testPoints = [
            { x: 0, y: 0, z: 0, r: 65535 },       // Center point (red)
            { x: 1, y: 0, z: 0, r: 32768 },       // X-axis (green)
            { x: 1.1, y: 0, z: 0, r: 32768 },       // X-axis (green)
            { x: 1.2, y: 0, z: 0, r: 32768 },       // X-axis (green)
            { x: 1.3, y: 0, z: 0, r: 32768 },       // X-axis (green)
            { x: 0, y: 1, z: 0, r: 16384 },       // Y-axis (blue-green)
            { x: 0, y: 1.1, z: 0, r: 16384 },       // Y-axis (blue-green)
            { x: 0, y: 0, z: 1, r: 0 },           // Z-axis (blue)
        ];

        // WebGL setup
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl');
        
        if (!gl) {
            alert('WebGL not supported');
            throw new Error('WebGL not supported');
        }

        // Vertex shader - transforms cylindrical coordinates to 3D space
        const vertexShaderSource = `
            attribute vec3 position;     // [x, y, z] in world space OR [radius_mm, row_index, reflect_intensity]
            attribute float pointSize;
            attribute float isTestPoint; // 1.0 for test points, 0.0 for data points
            
            uniform mat4 mvpMatrix;      // Model-View-Projection matrix
            uniform float rowSpacing;    // 10mm row spacing
            uniform float maxReflect;    // Max reflection for normalization
            
            varying float vReflect;      // Pass reflection to fragment shader
            varying float vIsTest;       // Pass test point flag
            
            void main() {
                vec3 worldPos;
                
                if (isTestPoint > 0.5) {
                    // Test points are already in world coordinates
                    worldPos = position;
                    vReflect = position.z; // Use z as reflection for test points
                } else {
                    // Data points need cylindrical to cartesian conversion
                    float radius = position.x / 1000.0;        // Convert mm to meters
                    float y = position.y * rowSpacing / 1000.0; // Row offset in meters
                    float angle = position.y * 0.1;            // Rotation angle per row
                    
                    // Convert cylindrical to cartesian (assuming rotation around Y-axis)
                    worldPos = vec3(
                        radius * cos(angle),
                        y,
                        radius * sin(angle)
                    );
                    
                    // Normalize reflection intensity for color mapping
                    vReflect = position.z / maxReflect;
                }
                
                gl_Position = mvpMatrix * vec4(worldPos, 1.0);
                gl_PointSize = pointSize;
                vIsTest = isTestPoint;
            }
        `;

        // Fragment shader - colors points based on reflection intensity
        const fragmentShaderSource = `
            precision mediump float;
            varying float vReflect;
            varying float vIsTest;
            
            void main() {
                vec3 color;
                
                if (vIsTest > 0.5) {
                    // Test points: bright colors for visibility
                    if (vReflect > 0.75) {
                        color = vec3(1.0, 0.0, 0.0);  // Red for high values
                    } else if (vReflect > 0.5) {
                        color = vec3(0.0, 1.0, 0.0);  // Green for medium values
                    } else if (vReflect > 0.25) {
                        color = vec3(0.0, 1.0, 1.0);  // Cyan for low-medium values
                    } else {
                        color = vec3(0.0, 0.0, 1.0);  // Blue for low values
                    }
                } else {
                    // Data points: gradient based on reflection
                    color = mix(
                        mix(vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 0.0), vReflect * 2.0),
                        vec3(1.0, 0.0, 0.0),
                        max(0.0, vReflect * 2.0 - 1.0)
                    );
                }
                
                gl_FragColor = vec4(color, 1.0);
            }
        `;

        // Compile shader helper
        function compileShader(gl, source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                throw new Error('Shader compilation error: ' + gl.getShaderInfoLog(shader));
            }
            return shader;
        }

        // Create shader program
        const vertexShader = compileShader(gl, vertexShaderSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);
        
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            throw new Error('Program linking error: ' + gl.getProgramInfoLog(program));
        }

        // Get attribute and uniform locations
        const positionLoc = gl.getAttribLocation(program, 'position');
        const pointSizeLoc = gl.getAttribLocation(program, 'pointSize');
        const isTestPointLoc = gl.getAttribLocation(program, 'isTestPoint');
        const mvpMatrixLoc = gl.getUniformLocation(program, 'mvpMatrix');
        const rowSpacingLoc = gl.getUniformLocation(program, 'rowSpacing');
        const maxReflectLoc = gl.getUniformLocation(program, 'maxReflect');

        // Create vertex buffer - combine test points and data points
        const totalPoints = depth.length + testPoints.length;
        const vertexData = new Float32Array(totalPoints * 3);
        const pointSizes = new Float32Array(totalPoints);
        const testPointFlags = new Float32Array(totalPoints);
        
        // Add test points first (guaranteed visible)
        for (let i = 0; i < testPoints.length; i++) {
            const baseIndex = i * 3;
            vertexData[baseIndex] = testPoints[i].x;
            vertexData[baseIndex + 1] = testPoints[i].y;
            vertexData[baseIndex + 2] = testPoints[i].z;
            pointSizes[i] = 10.0;  // Large points for visibility
            testPointFlags[i] = 1.0; // Mark as test point
        }
        
        // Add data points
        let maxReflectValue = 0;
        for (let i = 0; i < depth.length; i++) {
            const bufferIndex = testPoints.length + i;
            const baseIndex = bufferIndex * 3;
            vertexData[baseIndex] = depth[i];           // radius in mm
            vertexData[baseIndex + 1] = i;              // row index
            vertexData[baseIndex + 2] = reflect[i];     // reflection intensity
            
            pointSizes[bufferIndex] = 5.0;              // Visible point size
            testPointFlags[bufferIndex] = 0.0;          // Mark as data point
            maxReflectValue = Math.max(maxReflectValue, reflect[i]);
        }

        console.log('Total points:', totalPoints);
        console.log('Max reflection:', maxReflectValue);
        console.log('Test points:', testPoints.length);
        console.log('Data points:', depth.length);

        // Create and bind buffers
        const vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);

        const pointSizeBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, pointSizeBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, pointSizes, gl.STATIC_DRAW);

        const testPointBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, testPointBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, testPointFlags, gl.STATIC_DRAW);

        // Matrix utilities (minimal implementation)
        function createMatrix4() {
            return new Float32Array(16);
        }

        function perspective(out, fovy, aspect, near, far) {
            const f = 1.0 / Math.tan(fovy / 2);
            out[0] = f / aspect; out[1] = 0; out[2] = 0; out[3] = 0;
            out[4] = 0; out[5] = f; out[6] = 0; out[7] = 0;
            out[8] = 0; out[9] = 0; out[10] = (far + near) / (near - far); out[11] = -1;
            out[12] = 0; out[13] = 0; out[14] = (2 * far * near) / (near - far); out[15] = 0;
        }

        function lookAt(out, eye, center, up) {
            const z0 = eye[0] - center[0], z1 = eye[1] - center[1], z2 = eye[2] - center[2];
            const len = Math.sqrt(z0*z0 + z1*z1 + z2*z2);
            const zx = z0/len, zy = z1/len, zz = z2/len;
            
            const x0 = up[1]*zz - up[2]*zy, x1 = up[2]*zx - up[0]*zz, x2 = up[0]*zy - up[1]*zx;
            const xlen = Math.sqrt(x0*x0 + x1*x1 + x2*x2);
            const xx = x0/xlen, xy = x1/xlen, xz = x2/xlen;
            
            const yx = zy*xz - zz*xy, yy = zz*xx - zx*xz, yz = zx*xy - zy*xx;
            
            out[0] = xx; out[1] = yx; out[2] = zx; out[3] = 0;
            out[4] = xy; out[5] = yy; out[6] = zy; out[7] = 0;
            out[8] = xz; out[9] = yz; out[10] = zz; out[11] = 0;
            out[12] = -(xx*eye[0] + xy*eye[1] + xz*eye[2]);
            out[13] = -(yx*eye[0] + yy*eye[1] + yz*eye[2]);
            out[14] = -(zx*eye[0] + zy*eye[1] + zz*eye[2]);
            out[15] = 1;
        }

        function multiply(out, a, b) {
            const a00=a[0], a01=a[1], a02=a[2], a03=a[3];
            const a10=a[4], a11=a[5], a12=a[6], a13=a[7];
            const a20=a[8], a21=a[9], a22=a[10], a23=a[11];
            const a30=a[12], a31=a[13], a32=a[14], a33=a[15];
            
            const b00=b[0], b01=b[1], b02=b[2], b03=b[3];
            const b10=b[4], b11=b[5], b12=b[6], b13=b[7];
            const b20=b[8], b21=b[9], b22=b[10], b23=b[11];
            const b30=b[12], b31=b[13], b32=b[14], b33=b[15];
            
            out[0] = a00*b00 + a01*b10 + a02*b20 + a03*b30;
            out[1] = a00*b01 + a01*b11 + a02*b21 + a03*b31;
            out[2] = a00*b02 + a01*b12 + a02*b22 + a03*b32;
            out[3] = a00*b03 + a01*b13 + a02*b23 + a03*b33;
            out[4] = a10*b00 + a11*b10 + a12*b20 + a13*b30;
            out[5] = a10*b01 + a11*b11 + a12*b21 + a13*b31;
            out[6] = a10*b02 + a11*b12 + a12*b22 + a13*b32;
            out[7] = a10*b03 + a11*b13 + a12*b23 + a13*b33;
            out[8] = a20*b00 + a21*b10 + a22*b20 + a23*b30;
            out[9] = a20*b01 + a21*b11 + a22*b21 + a23*b31;
            out[10] = a20*b02 + a21*b12 + a22*b22 + a23*b32;
            out[11] = a20*b03 + a21*b13 + a22*b23 + a23*b33;
            out[12] = a30*b00 + a31*b10 + a32*b20 + a33*b30;
            out[13] = a30*b01 + a31*b11 + a32*b21 + a33*b31;
            out[14] = a30*b02 + a31*b12 + a32*b22 + a33*b32;
            out[15] = a30*b03 + a31*b13 + a32*b23 + a33*b33;
        }

        // Camera and rendering setup
        const projMatrix = createMatrix4();
        const viewMatrix = createMatrix4();
        const mvpMatrix = createMatrix4();
        
        let time = 0;
        let lastTime = performance.now();
        let frameCount = 0;
        let lastFpsUpdate = 0;

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
            
            // Update projection matrix
            perspective(projMatrix, Math.PI / 4, canvas.width / canvas.height, 0.1, 100.0);
        }

        function render() {
            const currentTime = performance.now();
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            time += deltaTime * 0.001;

            // FPS calculation
            frameCount++;
            if (currentTime - lastFpsUpdate > 1000) {
                document.getElementById('fps').textContent = Math.round(frameCount / ((currentTime - lastFpsUpdate) / 1000));
                frameCount = 0;
                lastFpsUpdate = currentTime;
            }

            // Clear canvas
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);

            // Camera rotation around the data
            const radius = 5.0;
            const eye = [
                Math.cos(time * 0.3) * radius,
                2.0,
                Math.sin(time * 0.3) * radius
            ];
            const center = [0, 0, 0];
            const up = [0, 1, 0];

            lookAt(viewMatrix, eye, center, up);
            multiply(mvpMatrix, projMatrix, viewMatrix);

            // Use shader program
            gl.useProgram(program);

            // Set uniforms
            gl.uniformMatrix4fv(mvpMatrixLoc, false, mvpMatrix);
            gl.uniform1f(rowSpacingLoc, 10.0);  // 10mm row spacing
            gl.uniform1f(maxReflectLoc, maxReflectValue);

            // Bind vertex attributes - minimize state changes
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.enableVertexAttribArray(positionLoc);
            gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, pointSizeBuffer);
            gl.enableVertexAttribArray(pointSizeLoc);
            gl.vertexAttribPointer(pointSizeLoc, 1, gl.FLOAT, false, 0, 0);

            // Draw points - single draw call for maximum performance
            gl.drawArrays(gl.POINTS, 0, depth.length);

            requestAnimationFrame(render);
        }

        // Initialize
        resize();
        window.addEventListener('resize', resize);
        
        // Update point count display
        document.getElementById('pointCount').textContent = depth.length;
        
        // Start render loop
        render();
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Massive Point Cloud Renderer</title>
    <style>
        body { margin: 0; padding: 0; background: #000; overflow: hidden; font-family: monospace; }
        canvas { display: block; }
        #ui { position: absolute; top: 10px; left: 10px; color: white; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; }
        #controls { position: absolute; top: 10px; right: 10px; color: white; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; }
        button { margin: 5px; padding: 5px 10px; }
        input[type="range"] { width: 100px; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="ui">
        <div>Points: <span id="pointCount">0</span></div>
        <div>FPS: <span id="fps">0</span></div>
        <div>GPU Memory: <span id="memory">0</span>MB</div>
        <div>Render Time: <span id="renderTime">0</span>ms</div>
    </div>
    <div id="controls">
        <div>Point Size: <input type="range" id="pointSize" min="0.1" max="5" value="1" step="0.1"></div>
        <div>LOD Distance: <input type="range" id="lodDistance" min="1" max="50" value="10" step="1"></div>
        <button id="generate1M">1M Points</button>
        <button id="generate5M">5M Points</button>
        <button id="toggleCulling">Toggle Culling</button>
    </div>

    <script>
        // Architecture for massive point clouds (5M+ points)
        // Uses: Instanced rendering, LOD, frustum culling, texture-based data storage
        
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2'); // WebGL2 for better performance
        
        if (!gl) {
            alert('WebGL2 not supported - this demo requires WebGL2 for optimal performance');
            throw new Error('WebGL2 not supported');
        }

        // Check for required extensions
        const ext = {
            anisotropic: gl.getExtension('EXT_texture_filter_anisotropic'),
            floatTexture: gl.getExtension('EXT_color_buffer_float')
        };

        // Configuration for different point counts
        const CONFIG = {
            maxPoints: 5000000,
            chunkSize: 100000,        // Process points in chunks
            lodLevels: 4,             // Number of LOD levels
            cullingEnabled: true,     // Frustum culling
            pointSizeRange: [0.1, 5.0]
        };

        // Vertex shader optimized for massive point rendering
        const vertexShaderSource = `#version 300 es
            precision highp float;
            
            // Attributes - minimal data per vertex
            in vec3 position;           // XYZ coordinates
            in float intensity;         // Single float for color/intensity
            
            // Uniforms
            uniform mat4 mvpMatrix;
            uniform vec3 cameraPos;
            uniform float pointSize;
            uniform float lodDistance;
            uniform vec2 viewport;
            
            // Outputs
            out float vIntensity;
            out float vDistance;
            flat out int vLOD;
            
            void main() {
                vec4 worldPos = vec4(position, 1.0);
                vec4 clipPos = mvpMatrix * worldPos;
                
                // Calculate distance to camera for LOD
                float distance = length(position - cameraPos);
                vDistance = distance;
                
                // LOD calculation - reduce point size with distance
                int lod = int(distance / lodDistance);
                vLOD = min(lod, 3);
                
                // Adaptive point size based on distance and screen resolution
                float screenScale = viewport.y / 1000.0;
                float adaptiveSize = pointSize * screenScale / (1.0 + distance * 0.1);
                
                // Skip tiny points (performance optimization)
                if (adaptiveSize < 0.1) {
                    gl_Position = vec4(2.0, 2.0, 2.0, 1.0); // Move off-screen
                    gl_PointSize = 0.0;
                } else {
                    gl_Position = clipPos;
                    gl_PointSize = adaptiveSize;
                }
                
                vIntensity = intensity;
            }
        `;

        // Fragment shader with efficient color mapping
        const fragmentShaderSource = `#version 300 es
            precision mediump float;
            
            in float vIntensity;
            in float vDistance;
            flat in int vLOD;
            
            out vec4 fragColor;
            
            // Efficient color palette - avoids complex calculations
            vec3 getColor(float intensity, int lod) {
                // Simple heat map: blue -> cyan -> green -> yellow -> red
                float t = clamp(intensity, 0.0, 1.0);
                
                // LOD-based alpha reduction for distant points
                float alpha = 1.0 - float(lod) * 0.2;
                
                vec3 color;
                if (t < 0.25) {
                    color = mix(vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 1.0), t * 4.0);
                } else if (t < 0.5) {
                    color = mix(vec3(0.0, 1.0, 1.0), vec3(0.0, 1.0, 0.0), (t - 0.25) * 4.0);
                } else if (t < 0.75) {
                    color = mix(vec3(0.0, 1.0, 0.0), vec3(1.0, 1.0, 0.0), (t - 0.5) * 4.0);
                } else {
                    color = mix(vec3(1.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), (t - 0.75) * 4.0);
                }
                
                return color * alpha;
            }
            
            void main() {
                // Circular point shape
                vec2 coord = gl_PointCoord - vec2(0.5);
                float dist = dot(coord, coord);
                if (dist > 0.25) discard;
                
                vec3 color = getColor(vIntensity, vLOD);
                fragColor = vec4(color, 1.0);
            }
        `;

        // Compile shader with error handling
        function compileShader(gl, source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                throw new Error('Shader compilation failed');
            }
            return shader;
        }

        // Create shader program
        const vertexShader = compileShader(gl, vertexShaderSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);
        
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            throw new Error('Program linking failed: ' + gl.getProgramInfoLog(program));
        }

        // Get locations
        const locations = {
            position: gl.getAttribLocation(program, 'position'),
            intensity: gl.getAttribLocation(program, 'intensity'),
            mvpMatrix: gl.getUniformLocation(program, 'mvpMatrix'),
            cameraPos: gl.getUniformLocation(program, 'cameraPos'),
            pointSize: gl.getUniformLocation(program, 'pointSize'),
            lodDistance: gl.getUniformLocation(program, 'lodDistance'),
            viewport: gl.getUniformLocation(program, 'viewport')
        };

        // Point cloud data structure
        class PointCloud {
            constructor(count) {
                this.count = count;
                this.generateData();
                this.createBuffers();
            }
            
            generateData() {
                console.log(`Generating ${this.count} points...`);
                const start = performance.now();
                
                // Simple Float32Array for maximum compatibility and performance
                // Layout: [x, y, z, intensity] per point
                this.data = new Float32Array(this.count * 4);
                
                // Generate random points in a cube with some interesting patterns
                for (let i = 0; i < this.count; i++) {
                    const base = i * 4;
                    
                    // Create some clustering for more interesting visuals
                    const clusterCenter = [
                        (Math.random() - 0.5) * 20,
                        (Math.random() - 0.5) * 20,
                        (Math.random() - 0.5) * 20
                    ];
                    
                    // Add some noise around cluster centers
                    this.data[base] = clusterCenter[0] + (Math.random() - 0.5) * 5;     // x
                    this.data[base + 1] = clusterCenter[1] + (Math.random() - 0.5) * 5; // y
                    this.data[base + 2] = clusterCenter[2] + (Math.random() - 0.5) * 5; // z
                    this.data[base + 3] = Math.random();                                // intensity
                }
                
                console.log(`Generated ${this.count} points in ${performance.now() - start}ms`);
            }
            
            createBuffers() {
                console.log('Creating GPU buffers...');
                const start = performance.now();
                
                // Create vertex array object for efficient state management
                this.vao = gl.createVertexArray();
                gl.bindVertexArray(this.vao);
                
                // Position buffer (vec3)
                this.positionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
                
                // Extract positions from interleaved data
                const positions = new Float32Array(this.count * 3);
                for (let i = 0; i < this.count; i++) {
                    positions[i * 3] = this.data[i * 4];
                    positions[i * 3 + 1] = this.data[i * 4 + 1];
                    positions[i * 3 + 2] = this.data[i * 4 + 2];
                }
                
                gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
                gl.enableVertexAttribArray(locations.position);
                gl.vertexAttribPointer(locations.position, 3, gl.FLOAT, false, 0, 0);
                
                // Intensity buffer (float)
                this.intensityBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.intensityBuffer);
                
                // Extract intensities from interleaved data
                const intensities = new Float32Array(this.count);
                for (let i = 0; i < this.count; i++) {
                    intensities[i] = this.data[i * 4 + 3];
                }
                
                gl.bufferData(gl.ARRAY_BUFFER, intensities, gl.STATIC_DRAW);
                gl.enableVertexAttribArray(locations.intensity);
                gl.vertexAttribPointer(locations.intensity, 1, gl.FLOAT, false, 0, 0);
                
                gl.bindVertexArray(null);
                
                // Calculate memory usage
                this.memoryUsage = (positions.byteLength + intensities.byteLength) / (1024 * 1024);
                
                console.log(`Created buffers in ${performance.now() - start}ms`);
                console.log(`GPU Memory: ${this.memoryUsage.toFixed(2)}MB`);
            }
            
            render(mvpMatrix, cameraPos, pointSize, lodDistance) {
                gl.bindVertexArray(this.vao);
                gl.drawArrays(gl.POINTS, 0, this.count);
            }
            
            destroy() {
                gl.deleteVertexArray(this.vao);
                gl.deleteBuffer(this.positionBuffer);
                gl.deleteBuffer(this.intensityBuffer);
            }
        }

        // Matrix utilities (optimized)
        class Matrix4 {
            constructor() {
                this.data = new Float32Array(16);
                this.identity();
            }
            
            identity() {
                this.data.fill(0);
                this.data[0] = this.data[5] = this.data[10] = this.data[15] = 1;
                return this;
            }
            
            perspective(fovy, aspect, near, far) {
                const f = 1.0 / Math.tan(fovy / 2);
                const nf = 1.0 / (near - far);
                
                this.data[0] = f / aspect;
                this.data[5] = f;
                this.data[10] = (far + near) * nf;
                this.data[11] = -1;
                this.data[14] = 2 * far * near * nf;
                this.data[15] = 0;
                return this;
            }
            
            lookAt(eye, target, up) {
                const z = [eye[0] - target[0], eye[1] - target[1], eye[2] - target[2]];
                const zLen = Math.sqrt(z[0]*z[0] + z[1]*z[1] + z[2]*z[2]);
                z[0] /= zLen; z[1] /= zLen; z[2] /= zLen;
                
                const x = [up[1]*z[2] - up[2]*z[1], up[2]*z[0] - up[0]*z[2], up[0]*z[1] - up[1]*z[0]];
                const xLen = Math.sqrt(x[0]*x[0] + x[1]*x[1] + x[2]*x[2]);
                x[0] /= xLen; x[1] /= xLen; x[2] /= xLen;
                
                const y = [z[1]*x[2] - z[2]*x[1], z[2]*x[0] - z[0]*x[2], z[0]*x[1] - z[1]*x[0]];
                
                this.data[0] = x[0]; this.data[1] = y[0]; this.data[2] = z[0]; this.data[3] = 0;
                this.data[4] = x[1]; this.data[5] = y[1]; this.data[6] = z[1]; this.data[7] = 0;
                this.data[8] = x[2]; this.data[9] = y[2]; this.data[10] = z[2]; this.data[11] = 0;
                this.data[12] = -(x[0]*eye[0] + x[1]*eye[1] + x[2]*eye[2]);
                this.data[13] = -(y[0]*eye[0] + y[1]*eye[1] + y[2]*eye[2]);
                this.data[14] = -(z[0]*eye[0] + z[1]*eye[1] + z[2]*eye[2]);
                this.data[15] = 1;
                return this;
            }
            
            multiply(other) {
                const result = new Float32Array(16);
                const a = this.data, b = other.data;
                
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 4; j++) {
                        result[i * 4 + j] = a[i * 4] * b[j] + a[i * 4 + 1] * b[j + 4] + 
                                          a[i * 4 + 2] * b[j + 8] + a[i * 4 + 3] * b[j + 12];
                    }
                }
                
                this.data.set(result);
                return this;
            }
        }

        // Renderer state
        let pointCloud = null;
        let time = 0;
        let lastTime = performance.now();
        let frameCount = 0;
        let lastFpsUpdate = 0;
        let renderTime = 0;
        
        const projMatrix = new Matrix4();
        const viewMatrix = new Matrix4();
        const mvpMatrix = new Matrix4();
        
        // Camera state
        const camera = {
            position: [0, 0, 30],
            target: [0, 0, 0],
            up: [0, 1, 0],
            fov: Math.PI / 4,
            near: 0.1,
            far: 1000
        };

        // UI Controls
        const controls = {
            pointSize: 1.0,
            lodDistance: 10.0,
            cullingEnabled: true
        };

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
            
            projMatrix.perspective(camera.fov, canvas.width / canvas.height, camera.near, camera.far);
        }

        function generatePointCloud(count) {
            if (pointCloud) {
                pointCloud.destroy();
            }
            
            pointCloud = new PointCloud(count);
            document.getElementById('pointCount').textContent = count.toLocaleString();
            document.getElementById('memory').textContent = pointCloud.memoryUsage.toFixed(2);
        }

        function render() {
            const currentTime = performance.now();
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            time += deltaTime * 0.001;
            
            const renderStart = performance.now();

            // FPS calculation
            frameCount++;
            if (currentTime - lastFpsUpdate > 1000) {
                const fps = Math.round(frameCount / ((currentTime - lastFpsUpdate) / 1000));
                document.getElementById('fps').textContent = fps;
                frameCount = 0;
                lastFpsUpdate = currentTime;
            }

            // Clear
            gl.clearColor(0.02, 0.02, 0.05, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

            if (pointCloud) {
                // Animate camera
                const radius = 40;
                camera.position[0] = Math.cos(time * 0.1) * radius;
                camera.position[2] = Math.sin(time * 0.1) * radius;
                camera.position[1] = Math.sin(time * 0.05) * 10;

                // Update matrices
                viewMatrix.lookAt(camera.position, camera.target, camera.up);
                mvpMatrix.data.set(projMatrix.data);
                mvpMatrix.multiply(viewMatrix);

                // Render
                gl.useProgram(program);
                gl.uniformMatrix4fv(locations.mvpMatrix, false, mvpMatrix.data);
                gl.uniform3fv(locations.cameraPos, camera.position);
                gl.uniform1f(locations.pointSize, controls.pointSize);
                gl.uniform1f(locations.lodDistance, controls.lodDistance);
                gl.uniform2f(locations.viewport, canvas.width, canvas.height);

                pointCloud.render(mvpMatrix, camera.position, controls.pointSize, controls.lodDistance);
            }

            renderTime = performance.now() - renderStart;
            document.getElementById('renderTime').textContent = renderTime.toFixed(2);

            requestAnimationFrame(render);
        }

        // Event listeners
        window.addEventListener('resize', resize);
        
        document.getElementById('pointSize').addEventListener('input', (e) => {
            controls.pointSize = parseFloat(e.target.value);
        });
        
        document.getElementById('lodDistance').addEventListener('input', (e) => {
            controls.lodDistance = parseFloat(e.target.value);
        });
        
        document.getElementById('generate1M').addEventListener('click', () => {
            generatePointCloud(1000000);
        });
        
        document.getElementById('generate5M').addEventListener('click', () => {
            generatePointCloud(5000000);
        });
        
        document.getElementById('toggleCulling').addEventListener('click', () => {
            controls.cullingEnabled = !controls.cullingEnabled;
        });

        // Initialize
        resize();
        generatePointCloud(100000); // Start with 100k points
        render();
    </script>
</body>
</html>